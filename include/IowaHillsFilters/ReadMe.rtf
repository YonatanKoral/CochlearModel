{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f57\froman\fcharset238\fprq2 Times New Roman CE;}
{\f58\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f60\froman\fcharset161\fprq2 Times New Roman Greek;}{\f61\froman\fcharset162\fprq2 Times New Roman Tur;}{\f62\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f63\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f64\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f65\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f77\fmodern\fcharset238\fprq1 Courier New CE;}
{\f78\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f80\fmodern\fcharset161\fprq1 Courier New Greek;}{\f81\fmodern\fcharset162\fprq1 Courier New Tur;}{\f82\fbidi \fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f83\fbidi \fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f84\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f85\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20 \ltrch\fcs0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}
{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\rsidtbl \rsid6313504\rsid10442972}{\*\generator Microsoft Word 11.0.0000;}{\info{\operator dan}{\creatim\yr2016\mo5\dy3\hr13\min47}{\revtim\yr2016\mo5\dy3\hr13\min50}{\version3}{\edmins1}{\nofpages3}
{\nofwords1092}{\nofchars6229}{\nofcharsws7307}{\vern24617}{\*\password 00000000}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}{\xmlns2 urn:schemas-microsoft-com:office:smarttags}}
\paperw12240\paperh15840\margl720\margr720\margt1440\margb1440\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\donotembedsysfont0\donotembedlingdata1\grfdocevents0\validatexml0\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind4\viewscale100\rsidroot10442972 \fet0{\*\wgrffmtfilter 013f}\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\sectdefaultcl\sectrsid6313504\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 
\f2\fs20\insrsid10442972 Iowa Hills Software, LLC
\par www.IowaHills.com
\par May 1, 2016
\par 
\par The Filter Code Kit consists of the following.
\par FFTCode.cpp            The FFT and other freq analysis algorithms.
\par FilterKitMain.cpp      Contains sample calls for the various functions in the kit.
\par FIRFilterCode.cpp      The FIR filter code.
\par FreqSamplingCode.cpp   FIR filters by frequency sampling.
\par IIRFilterCode.cpp      The IIR filter code.
\par LowPassPrototypes.cpp  Low pass prototype filter coefficients.
\par LowPassRoots.cpp       Calculates the roots for Butterworth, Cheby, etc.
\par NewParksMcClellan.cpp  The Parks McClellan FIR algorithm for FIR filters.
\par PFiftyOneRevC.cpp      A 100th order root finder.
\par QuadRootsCode.cpp      A Quartic root solver, called by P51.
\par CplxDMath.hpp          A complex math library (see the notes below).
\par 
\par 
\par With a bit of luck, you should be able to start a project, include these files i
n the project, compile, and run. The code uses the C++ Builder ShowMessage function to display warnings and errors in about 30 places. Since this isn't a standard C function, they have been commented out. Be sure to replace this function with something ap
propriate. If you are using C++ Builder, include vcl.h for ShowMessage.
\par 
\par If you get compilation errors because of undefined constants, such as M_PI and M_SQRT2 (Pi and sqrt(2), we included these definitions as comments in the FilterKitMain.h file, but we believe most compilers include these in the math.h file.
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 Visual C
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 If you are using Visual C, we have been told that this statement is needed in some of the files for the math constants. 
\par #define _USE_MATH_DEFINES
\par 
\par Also, the FIRFilterCode file contains a Sinc function that may need to be removed to avoid confusion with VC's Sinc function.
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 Complex Math
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 
Before the C11 standard was released, there wasn't a standard method for handling complex numbers in C. As a result, all the compilers handled them differently and used a wide range of syntax for complex numbers. 
\par 
\par To avoid this problem, previous versions of this kit didn't use complex math, but the inclusion of the low pass filter prototype code necessitated the use of complex variables and inclusion of our complex math library.
\par 
\par The library CplxDMath.hpp, was written by Iowa Hills Software, who are electr
ical engineers, not software professionals. CplxDMath should be good enough to get you started, but it should be replaced with your compiler's complex math library, which has been more properly vetted (at least in theory).
\par 
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 Attributions}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 
\par Most of the algorithms used here are essentially textbook algorithms. For example, the equations for the rectangular window FIR filters are developed in many textbooks. The code used here however, is our own work, except as noted. 
\par 
\par The Parks McClellan algorithm is obviously not our work, but we did this particular C translation. 
\par 
\par The quartic roots code is based on the code by Terence R.F.Nonweiler that was downloaded from http://www.netlib.org/toms Algorithm 326.
\par 
\par The P51 root finder is loosely based on the Jenkins Traub algorithm found at http://www.netlib.org/toms/  Algorithm 493.
\par 
\par The elliptic filter roots code was described in "Elliptic Functions for Filter Design" by H J Orchard and Alan N Willson.  IEE Trans on Circuits and Systems April 97. 
\par 
\par We derived the IIR  Bili
near Transform algorithm used here. Most authors describe a more complicated method that requires finding the roots of a frequency scaled Nth order polynomial. Our method relies on normalized second order s plane filter polynomials. One of the advantages 
o
f this method, is that a single set of filter coefficients can be used to generate any type of filter desired. For example, the normalized polynomial coefficients for a 4th order Butterworth can generate a 4th order Butterworth low pass, high pass, band p
ass, or notch filter, at any center frequency or bandwidth. See the IIREquationDerivations.pdf for details.
\par 
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 This code is guaranteed to have errors}{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 
, somewhere. If you find a problem, or would like to make a suggestion, please leave us a note at:  http://www.iowahills.com/feedbackcomments.html
\par 
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 Sampling Frequency
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 We get many questions regarding how the variables OmegaC and BW are related to the sampling frequency.
\par 
\par In the discrete time domain, there is no frequency greater than Pi, so all frequencies are gi
ven as a percentage of Pi. Or said a bit differently, all the frequency values are given as a percentage of Nyquist. This is consistent with the terminology used in most discrete time textbooks and is consistent with the frequency terminology used in a DF
T or FFT. 
\par 
\par For example, if the sampling freq = 20 kHz, then Nyquist = 10 kHz. For a band pass filter with a center frequency of 2 kHz and a 3 dB bandwidth of 500 Hz, set OmegaC = 0.2 and set BW = 0.05, which means 0.2 Pi and 0.05 Pi.
\par 
\par Clearly, we could have incorporated a sampling frequency into the code, but this is pure filter design code. In our view, the sampling frequency belongs at a higher level, in the user interface code. This filter design code doesn't use the sampling freque
ncy.
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 Denormal Numbers
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 
Just in case you have never heard of denormal numbers, I would like to suggest that you take some time to learn about them. When working with this type of code, we occasionally have problems with extremely slow execution times. For ex
ample, we might have trouble with the FFT requiring 100 X more time to execute than normal. The problem is that very small math values can slow execution times to a crawl.
\par 
\par In brief, when the processor executes a math instruction where the variables, and or the result, are less than DBL_{\*\xmlopen\xmlns2{\factoidname PersonName}}MI{\*\xmlclose}
N, it starts treating them as denormal, per the IEEE standard, and this takes a significant amount of time. You can read about it on Wikipedia or the Stack Overflow site.
\par 
\par This is not a problem unique to this cod
e. It is just that denormal math affects these types of algorithms a great deal. i.e. Algorithms that do millions of math operations, and you need to be aware of it. Per MSDN and Wikipedia, the processors math control registers can be modified to stop den
ormal math. This is supposed to allow the processor to flush small values to zero, as they say, but I haven't been able to make their instructions work.
\par 
\par The simple solution to this problem is to not allow math values to approach DBL_{\*\xmlopen\xmlns2{\factoidname PersonName}}MI{\*\xmlclose}N (2.23E-30
8), which usually means not using zero as an input value to an IIR filter or FFT. Use something like 1.0E-100 instead.
\par 
\par }{\rtlch\fcs1 \ab\af2\afs22 \ltrch\fcs0 \b\f2\fs22\insrsid10442972 {\*\xmlopen\xmlns2{\factoidname PlaceName}}{\*\xmlopen\xmlns2{\factoidname place}}Low{\*\xmlclose} {\*\xmlopen\xmlns2{\factoidname PlaceType}}Pass{\*\xmlclose}{\*\xmlclose}
 Prototype Filters
\par }{\rtlch\fcs1 \af2\afs20 \ltrch\fcs0 \f2\fs20\insrsid10442972 Previous versions of this kit contained a large table of filter coefficients for the various filter polynomials, such as the Butterworth and Elliptic.
\par 
\par This kit contains the code to calculate the pole zero locations for the various filter polynomials and generates the filter's second order polynomials, which is what we typically need for fi
lter design. These prototype filters are frequency scaled to ensure their 3 dB corner frequency is at 1 rad/sec. 
\par 
\par The code also orders the poles and zeros properly for use in opamp and IIR filters. In other words, from a mathematical point of view, the po
les and zeros can be matched and ordered in any manner, but for filter design, we need the poles and zeros mated and ordered in a manner that generates the smallest peak voltages for opamp filters and the smallest math values for IIR filters employing fix
ed point math. 
\par 
\par 
\par }}