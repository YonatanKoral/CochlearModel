
#include "state.h"

// Constructor:
CState::CState(
	double		time,
	double		time_step,
	long const  Fs,				// [Hz] Sampling rate
	CTriDiag&	TriMat,
	vector<double>*		input_buffer,
	long buffer_start_position,
	//CBin*		expected_file,
	CModel&		model,
	int param_set_counter
	) : 
	_time( time ),
	_time_step( time_step ),
	_Fs( Fs ),
	_Ts( 1/(double)Fs ),
	_TriMat( &TriMat ),
	_input_buffer( input_buffer ),
	_buffer_start_position(buffer_start_position),
	//_expected_file( expected_file ),
	_model( &model ),
	_params_set_counter(param_set_counter),
	// BM:
	_BM_disp(model._sections, 0),			// BM displacement
	_BM_sp(model._sections, 0),			// BM speed
	_BM_acc(model._sections, 0),			// BM acceleration
	_pressure(model._sections, 0),		// net pressure on membrane 
	// OHC:
	_p_ohc(model._sections, 0),			// OHC pressure
	_d_p_ohc(model._sections, 0),			// derivative of OHC pressure
	_psi_ohc(model._sections, 0),			// basolateral potential difference
	_d_psi_ohc(model._sections, 0),		// derivative of the basolateral potential difference
	_deltaL_disp(model._sections, 0),		// [m] length change as a function of OHC potential (psi).
	// TM
	_TM_disp(model._sections, 0),			// TM displacement
	_TM_sp(model._sections, 0),			// TM speed
	_p_TM(model._sections, 0),				// [Pa] the pressure generated by the TM
	// Cochlea
	_G(model._sections, 0), 				// G(x,t) from the pressure equation @^2P(x,t)/@t^2 - Q(x)*P(x,t) = G(x,t)
	_Y(model._sections, 0) 				// Y(x,t) from U*P = Y
{

	
	//cout << "State assigning start #" <<_params_set_counter << endl;
	// OW:
	_OW_disp = 0;		// OW membrane displacement
	_OW_sp = 0;			// OW membrane speed
	_OW_acc = 0;		// OW membrane acceleration
	
	_bc = 0;			// Boundary Condition
	max_samp = 0.0;

	
	//printf("Pressure assigned state #%d\n",_params_set_counter);
	
	//printf("OHC assigned state #%d\n",_params_set_counter);
	
	//_N_TM_sp.assign( _model->_sections, 0 );			// TM speed numerator (temproray vector)
	//_D_TM_sp.assign( _model->_sections, 0 );			// TM speed denominator (temproray vector)
	//_aux_TM.assign( _model->_sections, 0 );			// TM speed auxiliary vector (temproray vector for the tanh(x)^2-1 expression)
	//printf("TM assigned state #%d\n",_params_set_counter);
	//cout << "State assigning done #" << _params_set_counter << endl;
}

// d'tor
CState::~CState()	{}
/*
// Calc_DeltaL_OHC
vector<double> CState::Calc_DeltaL_OHC()
{
	if (true == _model->_OHC_NL_flag)
		_deltaL_disp = -_model->_alpha_s * tanh(_model->_alpha_L / _model->_alpha_s * _psi_ohc);
	else
		_deltaL_disp = -_model->_alpha_L * _psi_ohc;

	return _deltaL_disp;

}
*/
/*
// calc OHC pressure (Pohc)
vector<double> CState::Calc_Pohc()
{

	//vector<double> ohc_disp = OHC_Displacement();
	//vector<double> tmp1 =  _model->_S_ohc * ohc_disp;
	//vector<double> tmp2 =  _model->_S_ohc * OHC_Displacement();
	//vector<double> tmp3 =  _model->_gamma[_params_set_counter] * _model->_S_ohc * OHC_Displacement();
	//printf("gamma on set %d is %.3e",_params_set_counter,_model->_gamma[_params_set_counter]);
	_p_ohc = _model->configurations[_params_set_counter]._gamma * _model->_S_ohc * OHC_Displacement();
	return _p_ohc;
}
  */
/*
// Calc the Oval Window (OW) boundary condition at x = 0 (P(x,t))
double CState::Calc_BC( )								
{

	if (true == _model->_OW_flag)	{
		_bc = _model->_dx * _model->_a0 * (_model->_Gme*get_sample() - _model->_a1*_OW_disp - _model->_a2*_OW_sp);

	}else		// (false == _OW_flag)
		_bc = _model->_dx * _model->_a0 * _model->_Gme * get_sample();

	return _bc;

}
*/
/*
// Calc G(x,t) from the pressure equation @^2P(x,t)/@t^2 - Q(x)*P(x,t) = G(x,t), (WITHOUT the boundary conditions)
vector<double> CState::Calc_G()
{
    _G = -1.0*( _p_TM + R_bm_nl()*_BM_sp + _model->_S_bm*_BM_disp ); 

	return _G;

}
 */
/*
// Calc Y(x,t) from U*P = Y:
vector<double> CState::Calc_Y()
{
	double dx_pow2 = _model->_dx * _model->_dx;

	Calc_G( );				// G(x,t)
	Calc_BC( );				// Boundary conditions

	_Y = dx_pow2 * _G * _model->_Q;		// Y(x, t), WITHOUT the boundary condition (BC)
	_Y[0]					= _bc;							// P(x==0,t) (BC)
	_Y[_model->_sections - 1] = 0.0;							// P(x==L,t) == 0 (BC)
	
	return ( this->_Y );

}
*/

/*
//
// Calc BM acceleration
vector<double> CState::Calc_BM_Acceleration()
{
	_BM_acc = (_pressure + _G) / _model->_M_bm;

	return _BM_acc;
}
*/

/*
// Calc OW acceleration
double CState::Calc_OW_Acceleration( )
{
	if (false == _model->_OW_flag)
		_OW_acc = 0.0;
	
	else
		_OW_acc = 1.0 / _model->_sigma_ow * (_pressure[0] + _model->_Gme * get_sample()
		- _model->_a2 * _OW_sp - _model->_a1 * _OW_disp);

	return _OW_acc;

}
*/
/*
// Clac the psi's derivative
vector<double> CState::Calc_OHC_Psi_Deriv()
{
	_d_psi_ohc = _model->_eta_2*OHC_Speed() + _model->_eta_1*OHC_Displacement() - _model->_w_ohc*_psi_ohc;
	
	return _d_psi_ohc;

}
*/
/*
// Clac non-linear R_bm_nl(x) = R(x)*( 1 + alpha_r*BM_speed ) 
vector<double> CState::R_bm_nl()	{
	if (0 == _model->_alpha_r)
		return _model->_R_bm;
	else
		return (_model->_R_bm * (1.0 + _model->_alpha_r * _BM_sp ^ 2.0));

}
*/
/*
// Calc the OAE Pe(t) at the stapes:
double CState::Calc_OAE()	{
	return( get_sample() + _model->_Cme*_OW_disp ); 

}
 */
/*
// (OHC speed) = (TM speed) - (BM speed)
vector<double> CState::OHC_Speed()		{
	return ( _TM_sp - _BM_sp );

}
*/
/*
// (OHC displacement) = (TM displacement) - (BM displacement)
vector<double> CState::OHC_Displacement()	{

	//vector<double> OHC_disp = _TM_disp - _BM_disp;
	//return OHC_disp;
	return ( _TM_disp - _BM_disp );

}
  */
/*
// TM speed:
vector<double> CState::Calc_TM_speed()	{

	vector<double> N_TM_sp(_model->_sections, 0);		// TM speed numerator (temproray vector)
	vector<double> D_TM_sp(_model->_sections, 0);		// TM speed denominator (temproray vector)
	vector<double> aux_TM(_model->_sections, 0);		// TM speed auxiliary vector (temproray vector for the tanh(x)^2-1 expression)

	// Axiliary const - the nonlinear product of the OHC:
	if (true == _model->_OHC_NL_flag)	
		aux_TM = tanh(_model->_alpha_L/_model->_alpha_s*_psi_ohc)^2.0;	
	else	
		aux_TM = (_model->_alpha_L/_model->_alpha_s*_psi_ohc)^2.0;	
	
	aux_TM = _model->_alpha_L*( aux_TM - 1.0 );

	// Numerator:
	N_TM_sp = _p_ohc + _model->_S_tm*_TM_disp - _model->configurations[_params_set_counter]._gamma*( _model->_R_tm*aux_TM*
				(_model->_eta_2*_BM_sp + _model->_eta_1*OHC_Displacement() - _model->_w_ohc*_psi_ohc )
				+ _model->_S_tm*_deltaL_disp );
	
	// Denominator:
	D_TM_sp = _model->_R_tm*(_model->configurations[_params_set_counter]._gamma*aux_TM*_model->_eta_2 - 1.0);

	_TM_sp = N_TM_sp / D_TM_sp;

	return _TM_sp;

}
 */
/*
// TM pressure:
vector<double> CState::Calc_Ptm()	{
	_p_TM = _model->_R_tm*_TM_sp + _model->_S_tm*_TM_disp;
	return _p_TM;

} */
/*
// Implement one step for the current state ( 1 time step )
void CState::One_Time_Step( const CState past, const ODE_TYPE ode_type )
{

	if ( EULER == ode_type )
	{
		// BM displacement & speed
		this->_BM_disp	= Euler( past._BM_disp, past._BM_sp, _time_step ); 
		this->_BM_sp	= Euler( past._BM_sp, past._BM_acc, _time_step ); 

		// OW displacement & speed
		if (true == _model->_OW_flag)	{
			this->_OW_disp	= Euler( past._OW_disp, past._OW_sp, _time_step ); 
			this->_OW_sp	= Euler( past._OW_sp, past._OW_acc, _time_step ); 
		}

		// OHC
		this->_psi_ohc	= Euler( past._psi_ohc, past._d_psi_ohc, _time_step ); 

		// TM
		this->_TM_disp	= Euler( past._TM_disp, past._TM_sp, _time_step ); 


	}else	// ( TRAPEZIDAL == ode_type )
	{

		// BM displacement & speed
		this->_BM_disp	= Trapezoidal( past._BM_disp, past._BM_sp, _BM_sp, _time_step ); 
		this->_BM_sp	= Trapezoidal( past._BM_sp, past._BM_acc, _BM_acc, _time_step ); 

		// OW displacement & speed
		if (true == _model->_OW_flag)	{
			this->_OW_disp	= Trapezoidal( past._OW_disp, past._OW_sp, _OW_sp, _time_step ); 
			this->_OW_sp	= Trapezoidal( past._OW_sp, past._OW_acc, _OW_acc, _time_step ); 
		}

		// OHC
		this->_psi_ohc	= Trapezoidal( past._psi_ohc, past._d_psi_ohc, _d_psi_ohc, _time_step ); 

		// TM
		this->_TM_disp	= Trapezoidal( past._TM_disp, past._TM_sp, _TM_sp, _time_step ); 

	} 
	// OHC pressure contribution (Pohc):
	this->Calc_Pohc();

	// OHC electromotility alongation:
	this->Calc_DeltaL_OHC();

	// TM speed:
	this->Calc_TM_speed();

	// TM pressure:
	this->Calc_Ptm();

	// Calc Y (U*P = Y):
	this->Calc_Y();		// --> Y(x,t)

	// Solve P (U*P = Y):
	this->_pressure = _TriMat->SolveFor( _Y );	// --> P(x,t) 


	// BM acceleration:
	this->Calc_BM_Acceleration();

	// OW acceleration:
	this->Calc_OW_Acceleration();

	// OHC d(psi)/d(t):
	this->Calc_OHC_Psi_Deriv();				

}
*/
// copy state (relevant parameters only)
CState* CState::copy_state( const CState *const obj2copy )
{

	this->_time			= obj2copy->_time;				// Current state's time
	this->_time_step	= obj2copy->_time_step;			// Current state's time step

	// BM
	this->_BM_disp		= obj2copy->_BM_disp;			// BM displacement
	this->_BM_sp		= obj2copy->_BM_sp;				// BM speed
	this->_BM_acc		= obj2copy->_BM_acc;			// BM acceleration

	// TM
	this->_TM_disp		= obj2copy->_TM_disp;			// BM displacement
	this->_TM_sp		= obj2copy->_TM_sp;				// BM speed
	this->_p_TM			= obj2copy->_p_TM;				// BM speed

	// OW
	this->_OW_disp		= obj2copy->_OW_disp;			// OW membrane displacement
	this->_OW_sp		= obj2copy->_OW_sp;				// OW membrane speed
	this->_OW_acc		= obj2copy->_OW_acc;			// OW membrane acceleration

	// Cochlea
	this->_pressure		= obj2copy->_pressure;			// net pressure on membrane 

	// OHC
	this->_p_ohc		= obj2copy->_p_ohc;				// OHC pressure
	this->_d_p_ohc		= obj2copy->_d_p_ohc;			// derivative of OHC pressure
	this->_psi_ohc		= obj2copy->_psi_ohc;			// [V] basolateral potential difference
	this->_d_psi_ohc	= obj2copy->_d_psi_ohc;			// [V] derivative of the basolateral potential difference
	this->_deltaL_disp	= obj2copy->_deltaL_disp;		// [m] length change as a function of OHC potential (psi)
		
		//// !!! DEBUG - active gamma case !!!
		//this->_model->_gamma[_params_set_counter]	= obj2copy->_model->_gamma[_params_set_counter];	// OHC pressure
	
	// Cochlea
	this->_Y			= obj2copy->_Y; 				// G(x,t) from the pressure equation @^2P(x,t)/@t^2 - Q(x)*P(x,t) = G(x,t)

	return this;

}

// Update state's time & time step
CState* CState::restart_state( const double current_time, const double time_step )
{

	this->_time_step = time_step;
	this->_time = current_time;

	vector<double> zeros(_model->_sections, 0);

	//this->_in_sample			= NaN;
	this->_input_sample.clear();

	// BM
	this->_BM_disp		= zeros;		// BM displacement
	this->_BM_sp		= zeros;		// BM speed
	this->_BM_acc		= zeros;		// BM acceleration

	// OW
	this->_OW_disp		= 0;			// OW membrane displacement
	this->_OW_sp		= 0;			// OW membrane speed
	this->_OW_acc		= 0;			// OW membrane acceleration

	// TM
	this->_TM_disp		= zeros;		// TM displacement
	this->_TM_sp		= zeros;		// TM speed
	this->_p_TM			= zeros;		// net pressure on membrane 
		
	// Cochlea
	this->_pressure		= zeros;		// net pressure on membrane 

		//// !!! DEBUG - active gamma case !!!
		//this->_model->_gamma[_params_set_counter]	= zeros;	// OHC pressure

	// OHC
	this->_p_ohc		= zeros;		// OHC pressure
	this->_d_p_ohc		= zeros;		// derivative of OHC pressure
	this->_psi_ohc		= zeros;		// [V] basolateral potential difference
	this->_d_psi_ohc	= zeros;		// [V] derivative of the basolateral potential difference
	this->_deltaL_disp	= zeros;		// [m] length change as a function of OHC potential (psi)

	this->_Y			= zeros; 		// G(x,t) from the pressure equation @^2P(x,t)/@t^2 - Q(x)*P(x,t) = G(x,t)

	return this;

}



void CState::gen_input_data(std::vector<float>& inp_array, double start_time, int size, double freq, double amp)
{ 
 
	// relative position of x in the interval 

	double ttime = start_time;
	//if (ttime==0.0) ttime += (float)(_Ts );

	for (int i=0;i<size;i++)
	{

 
		double sin_factor = freq;
		double tmp_power = amp*sin(2.0*PI*(double)(sin_factor)*ttime); 

	//	printf("i=%d ttime=%e freq=%e amp=%e --> %e\n",i,ttime,sin_factor,amp,tmp_p); getchar();

	//tmp_p = INPUT_SIG_AMP*(double(rand()%10000)/10000.0);


		//printf("inp array[%d] = %e (arg = %e ttime=%e) TS=%e\n",i,tmp_p,2.0*PI*(double)(INPUT_SIG_FREQ)*ttime,ttime,_Ts); getchar();
		inp_array[i] = static_cast<float>(tmp_power);
		ttime += _Ts;
	}
 

}



void CState::load_input_data(std::vector<float>& inp_array, double start_time, int size, double amp)
{
 
	long pos = static_cast<long>( ceil(start_time / _Ts) );
	long start_pos = pos;
	//cout << "start position " << pos << "  for size " << size <<"\n";
	// relative position of x in the interval 
 
	//double *tmp_p = new double[size];
	
//	double pcalc;
	//_input_file->read_padd(tmp_p, pos, static_cast<long>(size)); no need for that we have input buffer
	int max_position = static_cast<int>(__tmin(static_cast<long>(size), static_cast<long>(_input_buffer->size()) - start_pos - _buffer_start_position));

	/*cout << "done read padd, start loading  #" << size << " indexes\n"
		<< "max position " << max_position << "\n";*/
	auto first = std::next(_input_buffer->begin(),start_pos);
	auto last = std::next(first,max_position);
	std::transform(first, last, inp_array.begin(), [amp](double d) { return static_cast<float>(d*amp); });
	if (max_position < size) { 
		std::generate(std::next(inp_array.begin(), max_position), std::next(inp_array.begin(), size), []() { return 0.0f; }); 
	}
	/*
	for (int i = 0; i<size; i++)
	{
		
		//beyond the buffer will load with zeros
		pcalc = i >= max_position ? 0 : (_input_buffer->at(i + start_pos)*amp);
		inp_array[i] =  static_cast<float>(pcalc);
		{
				if (fabs(pcalc)>max_samp)
				{
					max_samp = fabs(pcalc);
				}
		}
		pos++;
	}
	*/
	// << "done loading at " << pos << "\n";
	//free(tmp_p);
	//double max_amp = 20.0*log10(max_samp/(10*(20.0e-6)));
	//printf("READ FILE --> New Max = %e (%fdB)\n",max_samp,max_amp);
 

}



// Get input's sample at time t (pin(t))
double CState::get_sample( void )
{
# if VOICE_SIGNAL
	if ( _input_sample.empty() ) //(NaN == _in_sample)
		_input_sample.assign( 1, read_sample_from_file() );		
# else

	if ( _input_sample.empty() ) //(NaN == _in_sample)
		_input_sample.assign( 1, gen_new_sample() );	
# endif

	return _input_sample[0];
	
}


// Read the current sample from the input file:
double CState::gen_new_sample( void )
{
	long nearest = long( _time / _Ts );

	// relative position of x in the interval
	double delta = (_time - _Ts * nearest)/ _Ts ; 

	double p_t1, p_t2;

	double ttime = double(nearest)*_Ts;

	p_t1 = INPUT_SIG_AMP*sin(2.0*PI*(double)(INPUT_SIG_FREQ)*ttime);
	p_t2 = INPUT_SIG_AMP*sin(2.0*PI*(double)(INPUT_SIG_FREQ)*(ttime+_Ts));

	//printf("getting sin samples: ttime=%e (%d) ttime+Ts=%e (%d) Amp=%e Freq=%e --> %e\n",
//			ttime,nearest,ttime+_Ts,nearest+1,INPUT_SIG_AMP,(double)INPUT_SIG_FREQ,
			//(double)( p_t2 * delta + p_t1 * (1-delta) )); getchar();
 
	return ( p_t2 * delta + p_t1 * (1-delta) ); 

}



/*

// Read the current sample from the input file:
double CState::read_sample_from_file( void )
{
	long nearest = long( _time / _Ts );

	// relative position of x in the interval
	double delta = (_time - _Ts * nearest)/ _Ts ; 

	double p_t1, p_t2, p_res;

	_input_file->read( p_t1, nearest );

	if ( _input_file->_file_length <= ( nearest+1 ) )		
		// Looking at the end of the file? In this case use only one point for the interpulation!
		p_res =  ( p_t1 * (1-delta) );
	
	else	{
		_input_file->read( p_t2, nearest+1 );

		//printf("time %e Ts %e p_t1 = %e, p_t2 = %e delta = %e --> %e\n",_time,_Ts,p_t1,p_t2,delta,( p_t2 * delta + p_t1 * (1-delta) ));

		p_res =  ( p_t2 * delta + p_t1 * (1-delta) );
	}

	double abs_p_res = (p_res>0.0) ? p_res : (-p_res);

	max_samp = (abs_p_res>max_samp) ? abs_p_res : max_samp;

	return p_res;
}
 */
